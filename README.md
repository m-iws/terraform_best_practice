# AWSのベストプラクティスに沿ってTerraformを使用してみる<!-- omit in toc -->

## 今回の目的<!-- omit in toc -->

前回、初めてTerraformに挑戦しましたが、今回は前回の成果物をAWSのベストプラクティスに沿って見直してみました。<br>
間違いも足りない部分も多々あるかと思いますが、現状できる範囲でベストを尽くします。<br>※今回は、リソース構築部分に限定し、監視・検証に関わる部分はスキップしています。<br>
[前回作成したコード](https://github.com/m-iws/terrform_study)<br>
[Best practices for using the Terraform AWS Provider](https://docs.aws.amazon.com/prescriptive-guidance/latest/terraform-aws-provider-best-practices/introduction.html)

---

## 今回行うこと<!-- omit in toc -->

[AWS公式ドキュメントのベストプラクティス](https://docs.aws.amazon.com/prescriptive-guidance/latest/terraform-aws-provider-best-practices/introduction.html)に沿って、[前回](https://github.com/m-iws/terrform_study)から認証方法やリソースの構成・設定を修正します。<br>
2024年6月現在は日本語の翻訳記事がなかったため、Google Chromeの翻訳を参考にしました。<br>

<主に参考にした部分>

- セキュリティのベストプラクティス
- バックエンドのベストプラクティス
- コードベース構造と構成に関するベストプラクティス

※AWSプロバイダーのバージョン管理、コミュニティモジュールのベストプラクティスに関しては、現在の個人開発環境には該当しないと判断し、今回はスキップしました。

---

## 開発環境<!-- omit in toc -->

Windows 11 Home<br>
Gitは導入済み

---

## 構成図<!-- omit in toc -->

今回作成するリソースの構成図です（前回と変更なし）。<br>

- CRUD処理ができる簡易なアプリケーションのシステム構成図を想定
- S3はアプリケーションの画像の保存先として利用を想定
- RDSはマルチAZ構成とし可用性や耐障害性を高める構成とした<br>
<img width="450" src=img/構成図.png>

---

## 手順<!-- omit in toc -->

- [1. セキュリティのベストプラクティス](#1-セキュリティのベストプラクティス)
  - [IAMロールを使用して最小権限でアクセスする](#iamロールを使用して最小権限でアクセスする)
- [2. バックエンドのベストプラクティス](#2-バックエンドのベストプラクティス)
  - [リモート状態ロックを有効にする](#リモート状態ロックを有効にする)
- [3. コードベース構造と構成に関するベストプラクティス](#3-コードベース構造と構成に関するベストプラクティス)
  - [README.mdを作成](#readmemdを作成)
  - [疑似リソースではなくアタッチメントリソースを使用する](#疑似リソースではなくアタッチメントリソースを使用する)

### 1. セキュリティのベストプラクティス

---

認証、アクセス制御、セキュリティを適切に管理することが重要。<br>
下記の内容を読み取れたので、それに沿って修正していきます。

- 最小権限の原則に従う
  - IAMロールを使用して最小権限でアクセスする
    - IAMユーザーではなくIAMロールを使用
    - IAMポリシーを使用して最小権限のアクセスを付与。空のポリシーから始めて、許可されたサービスとアクションを繰り返し追加する。
- ~~安全なリモート状態ストレージ~~　←前回実行済み
- ~~AWS Secrets Managerを使用する~~　←前回実行済み

---

#### IAMロールを使用して最小権限でアクセスする

---

最小権限の原則のもと、IAMロールを使用して認証します。<br>
<主な利点>

- 長期間有効なアクセスキーに比べてセキュリティが向上する
- 最小限の権限でロールにきめ細かなアクセス制御を行えること
- ロールの権限を変更することでアクセスを簡単に取り消すことができる

前回はIAMユーザー＆アクセスキーを作成してアクセスしたため、今回はそのIAMユーザーからAssume RoleしたIAMロールを使用したアクセス方法へ変更しました。<br>
[参考サイト](https://blog.mmmcorp.co.jp/2021/01/27/terraform_with_assume_role/)

まずはIAMロールを作成しますが、その前に必要な権限をリストアップします。<br>
今回はpikeというツールを使用して必要な権限をピックアップしました。<br>
[pike](https://github.com/JamesWoolfenden/pike?tab=readme-ov-file)

Windowsの場合、まずはPowerShellでscoopというアプリ自動導入＆管理ツールをインストールします。

```ps
PS: Set-ExecutionPolicy RemoteSigned -Scope CurrentUser -Force
PS: iwr -useb get.scoop.sh | iex
```

次に公式サイトを参考にgit bashでpikeをインストールします。

```bash
$ scoop bucket add iac https://github.com/JamesWoolfenden/scoop.git
$ scoop install pike
```

あとはmain.tfがあるディレクトリを指定して、pikeを実行すると作成したTerraformの構成ファイルを実行するために必要な信頼ポリシーが作成されます。<br>
※以下は今回作成されたポリシーの一部です。

```bash
$ pike scan -o terraform -d ./terraform
resource "aws_iam_policy" "terraform_pike" {
  name_prefix = "terraform_pike"
  path        = "/"
  description = "Pike Autogenerated policy from IAC"

  policy = jsonencode({
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "dynamodb:DeleteItem",
                "dynamodb:DescribeTable",
                "dynamodb:GetItem",
                "dynamodb:PutItem"
            ],
            "Resource": [
                "*"
            ]
        },
```

`pike make .`コマンドでポリシーとIAMロールが自動作成できるようですが、今回は理解を深めるためにもAWSコンソール上でIAMロールを新規作成し、上記で作成されたポリシーを設定しました。<br>
ただ、一部の権限が足りていなかったので都度追加しました。<br>

次に以前作成したIAMユーザーの信頼ポリシーを空にし、先ほど作成したIAMロールにAssume Roleする権限のみを記載します。

```Json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "[作成したIAMロールのarn]"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```

最後に、providerとbackendの設定でIAMロールを指定します。

```Json

provider "aws" {
  assume_role {
    role_arn     = "[作成したIAMロールのarn]"
  }
}
```

```json
backend "s3" {
    bucket = "[tfstateファイル保存用に作成したバケット名]"
    region = "[リージョンを指定]"
    key    = "terraform.tfstate"
    role_arn = "[作成したIAMロールのarn]"
  }
```

---

### 2. バックエンドのベストプラクティス

---

下記の内容を読み取れたので、それに沿って修正していきます。
- ~~リモートストレージにAmazonS3を使用する~~　←前回実行済み
  - <利点>
    - データの損失
    - 構成が管理不能となる
    - 不注意によるリソースの削除
    - 機密情報の漏洩
- ~~S3のサーバー暗号化（SSE）を使用~~　←前回実行済み
- リモート状態ロックを有効にする

---

#### リモート状態ロックを有効にする

---

複数ユーザによる同時変更を防ぐためDynamoDBロックを設定する事が推奨されています。<br>
s3は同時書き込みのオブジェクトロックをサポートしていないため、今回は作成したDynamoDBをbackendで指定します。<br>
DynamoDBはCloudformationで別途作成しました。<br>
[backend.yml](backend.yml)<br>
[参考サイト](https://blog-benri-life.com/terraform-state-lock-s3/)

```json
backend "s3" {
    bucket = "[tfstateファイル保存用に作成したバケット名]"
    region = "[リージョンを指定]"
    key    = "terraform.tfstate"
    role_arn = "[作成したIAMロールのarn]"
    dynamodb_table = "TerraformStateLocking" 
  }
```

---

### 3. コードベース構造と構成に関するベストプラクティス

---

このドキュメントに基づき、下記の内容分を修正しました。

- 標準的なリポジトリ構造を実装する
  - サービス名付きファイルは避け、できるだけmain.tfを使用。
    - ただ、リソースコレクションが150行を超える場合は独自ファイルに分割する。⇒メインリソース以外（IAMロールなど）を独自ファイルとする構成へと修正した。
  - モジュールの説明と使用目的を含めるREADME.mdを作成する。
- 疑似リソースではなくアタッチメントリソースを使用する
  - リソースの依存関係を明確にできる。
  - 変更や更新が容易になる。

---

#### README.mdを作成

---

terraform-docsを使用してREADMEを作成します。<br>
こちらもscoopを使用してインストールしました。

[terraform-docs公式](https://terraform-docs.io/user-guide/installation/)


```bash
$ scoop bucket add terraform-docs https://github.com/terraform-docs/scoop-bucket
$ scoop install terraform-docs
```

```bash
$ terraform-docs markdown [main.tfがあるディレクトリ]
```

こんな感じで出力されました！（一部を抜粋しています）<br>
[README.md](terraform/README.md)

```md

## Requirements

| Name | Version |
|------|---------|
| <a name="requirement_terraform"></a> [terraform](#requirement\_terraform) | >=1.4.4 |

## Providers

| Name | Version |
|------|---------|
| <a name="provider_aws"></a> [aws](#provider\_aws) | 5.55.0 |

## Modules

No modules.

## Resources
～以下省略

```

---

#### 疑似リソースではなくアタッチメントリソースを使用する

---

セキュリティグループなどのリソースでは、疑似リソースが属性として埋め込まれていますが、ベストプラクティスではアタッチメントリソースの使用が推奨されています。<br>
<主な利点>

- リソースの依存関係を明確にできる。
- 変更や更新が容易になる。特にセキュリティグループなどのように頻繁に変更が必要になるリソースでは、ルールを個別にアタッチする方が管理が容易である。

疑似リソースの使用例：

```json
resource "aws_security_group" "allow_tls" {
  ...
  ingress {
    description      = "TLS from VPC"
    from_port        = 443
    to_port          = 443
    protocol         = "tcp"
    cidr_blocks      = [aws_vpc.main.cidr_block]
    ipv6_cidr_blocks = [aws_vpc.main.ipv6_cidr_block]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }
}

```

推奨される使用例：

```json
resource "aws_security_group" "allow_tls" {
  ...
}

resource "aws_security_group_rule" "example" {
  type              = "ingress"
  description      = "TLS from VPC"
  from_port        = 443
  to_port          = 443
  protocol         = "tcp"
  cidr_blocks      = [aws_vpc.main.cidr_block]
  ipv6_cidr_blocks = [aws_vpc.main.ipv6_cidr_block]
  security_group_id = aws_security_group.allow_tls.id
}
```

上記例に基づいて、セキュリティグループの記述を変更しました。<br>
埋め込み属性ではなく、それぞれingressとegressのルールを作成し、セキュリティグループへアタッチする記述へ修正しました。

```json

resource "aws_security_group" "ec2_sg" {
  name        = "${var.tag_name}-ec2-sg"
  description = "for ec2"
  vpc_id      = aws_vpc.main.id

  tags = {
    Name = "${var.tag_name}-ec2-sg"

  }
}

resource "aws_vpc_security_group_ingress_rule" "allow_ec2_sg_elb" {
  security_group_id = aws_security_group.ec2_sg.id
  cidr_ipv4         = var.vpc_allow
  from_port         = 80
  ip_protocol       = "tcp"
  to_port           = 80
}

resource "aws_vpc_security_group_ingress_rule" "allow_ec2_sg_ssh" {
  security_group_id = aws_security_group.ec2_sg.id
  cidr_ipv4         = var.vpc_allow
  from_port         = 22
  ip_protocol       = "tcp"
  to_port           = 22
}

resource "aws_vpc_security_group_ingress_rule" "allow_ec2_sg_app" {
  security_group_id = aws_security_group.ec2_sg.id
  cidr_ipv4         = var.vpc_allow
  from_port         = 3000
  ip_protocol       = "tcp"
  to_port           = 3000
}

resource "aws_vpc_security_group_egress_rule" "allow_egree_ec2_sg" {
  security_group_id = aws_security_group.ec2_sg.id
  cidr_ipv4         = var.vpc_allow
  ip_protocol       = "-1" # semantically equivalent to all ports
}
```

---

## 反省点と感想<!-- omit in toc -->

- 公式ドキュメントは一文ずつ丁寧に確認したつもりだが、まだまだTerraformについて理解が足りない部分が多く、漏れがあると思われる。
- まだ理解が足りず、複数リソースの作成に関数など使用できていない。
- CI/CDツールとの連携に関する内容も多く、今回の個人開発では着手できないベストプラクティスが多々あった。
- 個人の勉強も進めていきたいが、やはり早く現場に参入し実務で様々なスキルを身に付けたいという思いがより強くなった。
